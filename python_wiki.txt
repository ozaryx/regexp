{{Другие значения}}
{{Карточка языка программирования
 |name                   = Python
 |logo                 =Python logo and wordmark.svg
 |semantics              =- 
 |paradigm               = [[Мультипарадигмальный язык программирования|мультипарадигмальный]]: <br />[[Объектно-ориентированный язык программирования|объектно-ориентированный]], <br />[[Отражение (программирование)|рефлективный]], <br />[[Императивный язык программирования|императивный]], <br />[[Функциональный язык программирования|функциональный]], <br />[[Аспектно-ориентированное программирование|аспектно-ориентированный]], <br />[[Динамический язык программирования|динамический]]
 |class                  = [[Интерпретатор|интерпретируемый]], [[Компилятор|компилируемый]] в [[Common Intermediate Language|MSIL]], компилируемый в [[байт-код]] [[Java]]
 |extension              = .py, .pyw, .pyc, .pyo, .pyd<ref>
* .py — исходный код.
* .pyw — исходный код для выполнения программ с графическим интерфейсом в Windows, файлы с таким расширением будут выполнены без запуска консоли.
* .pyc — скомпилированный байт-код.
* .pyo — оптимизированный скомпилированный байт-код.
* .pyd — бинарный код динамических библиотек [[Динамически подключаемая библиотека|DLL]] (в Windows).</ref>
 | latest_release_version = 3.5.0/ 2.7.10
 | latest_release_date    = [[13 сентября]] [[2015 год]]а<ref name="latest3">[https://www.python.org/downloads/release/python-350/ Python Release Python 3.5.0]</ref> / 23 мая [[2015 год]]а<ref name="latest2">[https://www.python.org/downloads/release/python-2710/ Python Release Python 2.7.10]</ref>
 | latest_preview_version = 
 | latest_preview_date    = 
 |typing                 = [[Строгая типизация|строгая]], [[Динамическая типизация|динамическая]]
 |implementations        = [[CPython]], [[Jython]], [[IronPython]], [[PyPy]], [[Stackless Python|Stackless]]
 |dialects               = 
 |influenced_by          = [[ABC (язык программирования)|ABC]], [[Модула-3|Modula-3]], [[Lisp]], [[Tcl]], [[Smalltalk]], [[Си (язык программирования)|C]], [[Java]], [[Icon (язык программирования)|Icon]]
 |influenced             = [[Ruby]], [[Boo]], [[Groovy]], [[ECMAScript]], [[CoffeeScript]], [[Swift (язык программирования)|Swift]]
}}
[[Файл:PythonProgLogo.png|thumb|Логотип Python (1990—2005)]]
'''Python'''<ref>Создатель языка Гвидо ван Россум настаивает, что название происходит не от [[Питоны|рептилии]] и не от [[Пифон|мифического существа]], а от телевизионного шоу «[[Летающий цирк Монти Пайтона]]». См.: http://docs.python.org/faq/general#why-is-it-called-python, однако стилизованное изображение змеи давно стало неофициальным символом языка и является элементом официального логотипа.</ref> (<small>МФА:</small> {{IPA|[ˈpʌɪθ(ə)n]}}; в русском языке распространено название ''пито́н''<ref>[http://www.xakep.ru/magazine/xa/117/088/1.asp Мария «Mifrill» Нефедова, Создатели языков программирования: Они такие разные, но кодинг их объединяет, Хакер № 09/08 (117)]</ref>) — [[высокоуровневый язык программирования]] общего назначения, ориентированный на повышение производительности разработчика и читаемости кода. [[Синтаксис (программирование)|Синтаксис]] ядра Python минималистичен. В то же время [[Стандартная библиотека Python|стандартная библиотека]] включает большой объём полезных функций.

Python поддерживает несколько [[Парадигма программирования|парадигм программирования]], в том числе [[структурное программирование|структурное]], [[объектно-ориентированное программирование|объектно-ориентированное]], [[функциональное программирование|функциональное]], [[императивное программирование|императивное]] и [[аспектно-ориентированное программирование|аспектно-ориентированное]]. Основные архитектурные черты — [[динамическая типизация]], [[сборка мусора (программирование)|автоматическое управление памятью]], полная [[Интроспекция (программирование)|интроспекция]], механизм [[обработка исключений|обработки исключений]], поддержка [[многопоточность|многопоточных вычислений]] и удобные высокоуровневые [[структура данных|структуры данных]]. Код в Python организовывается в функции и [[Класс (программирование)|классы]], которые могут объединяться в [[Модуль (программирование)|модули]] (они в свою очередь могут быть объединены в пакеты).

Эталонной реализацией Python является интерпретатор [[CPython]], поддерживающий большинство активно используемых платформ<ref>[http://www.python.org/about/ About Python]</ref>. Он распространяется под [[свободное программное обеспечение|свободной лицензией]] Python Software Foundation License, позволяющей использовать его без ограничений в любых приложениях, включая [[проприетарное ПО|проприетарные]]<ref>[http://www.python.org/2.5/license.html Python 2.5 license<!-- Заголовок добавлен ботом -->]</ref>. Есть реализации интерпретаторов для [[JVM]] (с возможностью [[Компилятор|компиляции]]), [[MSIL]] (с возможностью [[Компилятор|компиляции]]), [[LLVM]] и других. Проект [[PyPy]] предлагает реализацию Python на самом Python, что уменьшает затраты на изменения языка и постановку экспериментов над новыми возможностями.

Python — активно развивающийся [[язык программирования]], новые версии (с добавлением/изменением языковых свойств) выходят примерно раз в два с половиной года. Вследствие этого и некоторых других причин на Python отсутствуют [[Американский национальный институт стандартов|стандарт ANSI]], [[ISO]] или другие официальные стандарты, их роль выполняет [[CPython]].

== Философия ==
<!-- на этот заголовок есть ссылка из текста статьи -->
Разработчики языка Python придерживаются определённой философии программирования, называемой «The Zen of Python» («[[Дзен]] Питона», или «Дзен Пайтона»)<ref>[http://www.python.org/peps/pep-0020.html PEP 20 — The Zen of Python]</ref>. Её текст выдаётся [[интерпретатор]]ом Python по команде <code>import this</code> (работает один раз за сессию). Автором этой философии считается [[Тим Петерс|Тим Петерс]] (Tim Peters).

Текст философии:
{{начало цитаты}}
* Красивое лучше, чем уродливое.
* Явное лучше, чем неявное.
* Простое лучше, чем сложное.
* Сложное лучше, чем запутанное.
* Плоское лучше, чем вложенное.
* Разреженное лучше, чем плотное.
* Читаемость имеет значение.
* Особые случаи не настолько особые, чтобы нарушать правила.
* При этом практичность важнее безупречности.
* Ошибки никогда не должны замалчиваться.
* Если не замалчиваются явно.
* Встретив двусмысленность, отбрось искушение угадать.
* Должен существовать один — и, желательно, ''только'' один — очевидный способ сделать это.
* Хотя он поначалу может быть и не очевиден, если вы не голландец<ref>Шутливый намёк на Гвидо</ref>.
* Сейчас лучше, чем никогда.
* Хотя никогда зачастую лучше, чем ''прямо'' сейчас.
* Если реализацию сложно объяснить — идея плоха.
* Если реализацию легко объяснить — идея, ''возможно'', хороша.
* Пространства имён — отличная штука! Будем делать их побольше!
{{oq|en|
* Beautiful is better than ugly.
* Explicit is better than implicit.
* Simple is better than complex.
* Complex is better than complicated.
* Flat is better than nested.
* Sparse is better than dense.
* Readability counts.
* Special cases aren’t special enough to break the rules.
* Although practicality beats purity.
* Errors should never pass silently.
* Unless explicitly silenced.
* In the face of ambiguity, refuse the temptation to guess.
* There should be one — and preferably only one — obvious way to do it.
* Although that way may not be obvious at first unless you’re Dutch.
* Now is better than never.
* Although never is often better than 'right now'.
* If the implementation is hard to explain, it’s a bad idea.
* If the implementation is easy to explain, it may be a good idea.
* Namespaces are one honking great idea — let’s do more of those!
}}{{конец цитаты}}

== История ==
{{main|История языка программирования Python}}
Разработка языка Python была начата в конце [[1980-е|1980-х годов]]<ref>[http://www.artima.com/intv/pythonP.html The Making of Python<!-- Заголовок добавлен ботом -->]</ref> сотрудником голландского института CWI [[Гвидо ван Россум]]ом. Для распределённой ОС [[Amoeba (операционная система)|Amoeba]] требовался расширяемый [[Сценарный язык|скриптовый язык]], и Гвидо начал писать Python на досуге, позаимствовав некоторые наработки для языка [[ABC (язык программирования)|ABC]] (Гвидо участвовал в разработке этого языка, ориентированного на обучение программированию). В феврале [[1991 год]]а Гвидо опубликовал исходный текст в [[Группа новостей|ньюсгруппе]] alt.sources<ref>http://svn.python.org/view/*checkout*/python/trunk/Misc/HISTORY</ref>. С самого начала Python проектировался как [[объектно-ориентированный язык программирования|объектно-ориентированный язык]].

[[Файл:Python-icon.png|thumb|left|<!--Пиктограмма для файлов -->.py]]
Название языка произошло вовсе не от вида пресмыкающихся. Автор назвал язык в честь популярного британского комедийного телешоу [[1970-е|1970-х]] «[[Летающий цирк Монти Пайтона]]». Впрочем, всё равно название языка чаще ассоциируют именно со змеёй, нежели с передачей — [[пиктограмма|пиктограммы]] файлов в [[KDE]] или в [[Microsoft Windows]] и даже эмблема на сайте python.org (до выхода версии 2.5) изображают змеиные головы.

Наличие дружелюбного, отзывчивого сообщества пользователей считается наряду с дизайнерской интуицией Гвидо одним из факторов успеха Python. Развитие языка происходит согласно чётко регламентированному процессу создания, обсуждения, отбора и реализации документов PEP ({{lang-en|Python Enhancement Proposal}}) — предложений по развитию Python<ref>[http://www.python.org/dev/peps/ Index of Python Enhancement Proposals (PEPs)]</ref>.

[[3 декабря]] [[2008 год]]а<ref>[http://python.org/download/releases/3.0/ Python 3.0 Release<!-- Заголовок добавлен ботом -->]</ref>, после длительного тестирования, вышла первая версия Python 3000 (или Python 3.0, также используется [[Аббревиатура|сокращение]] Py3k). В Python 3000 устранены многие недостатки архитектуры с максимально возможным (но не полным) сохранением совместимости со старыми версиями Python. На сегодня поддерживаются обе ветви развития (Python 3.x и 2.x).

=== Влияние других языков на Python ===
Появившись сравнительно поздно, Python создавался под влиянием множества языков программирования:
* [[ABC (язык программирования)|ABC]] — отступы для группировки операторов, высокоуровневые структуры данных (map)<ref name="foreword">[http://www.python.org/doc/essays/foreword/ Foreword for «Programming Python» (1st ed.)<!-- Заголовок добавлен ботом -->]</ref><ref>[http://www.artima.com/intv/python2.html The Making of Python<!-- Заголовок добавлен ботом -->]</ref> (Python фактически создавался как попытка исправить ошибки, допущенные при проектировании ABC);
* [[Модула-3|Modula-3]] — пакеты, модули, использование <code>else</code> совместно с <code>try</code> и <code>except</code>, именованные аргументы функций (на это также повлиял [[Common Lisp]]);
* [[С (язык программирования)|С]], [[C++]] — некоторые синтаксические конструкции (как пишет сам [[Гвидо ван Россум]] — он использовал наиболее непротиворечивые конструкции из С, чтобы не вызвать неприязнь у С-программистов к Python<ref name="foreword"/>);
* [[Smalltalk]] — объектно-ориентированное программирование;
* [[Lisp]] — отдельные черты [[функциональное программирование|функционального программирования]] (<code lang="python">lambda, map, reduce, filter</code> и другие);
* [[Fortran]] — срезы массивов, комплексная арифметика;
* [[Миранда (язык программирования)|Miranda]] — [[Функциональное программирование на Питоне#Списочные выражения|списочные выражения]];
* [[Java]] — модули logging, unittest, threading (часть возможностей оригинального модуля не реализована), xml.sax стандартной библиотеки, совместное использование finally и except при обработке исключений, использование @ для [[#Декораторы|декоратор]]ов;
* [[Icon (язык программирования)|Icon]] — [[Python#Генераторы|генераторы]].

Большая часть других возможностей Python (например, байт-компиляция исходного кода) также была реализована ранее в других языках.

== Портируемость ==
Python [[Портирование программного обеспечения|портирован]] и работает почти на всех известных платформах — от [[Карманный персональный компьютер|КПК]] до [[мейнфрейм]]ов. Существуют порты под [[Microsoft Windows]], практически все варианты [[UNIX]] (включая [[FreeBSD]] и [[Linux]]), [[Plan 9]], [[Mac OS]] и [[Mac OS X]], [[iPhone OS]] 2.0 и выше, [[Palm OS]], [[OS/2]], [[Amiga]], [[HaikuOS]], [[AS/400]] и даже [[OS/390]], [[Windows Mobile]], [[Symbian]] и [[Android]]<ref>{{cite web|url=http://www.damonkohler.com/2008/12/python-on-android.html|title=Python on Android|publisher=www.damonkohler.com|accessdate=19 декабря 2009 |lang=en |archiveurl=http://www.webcitation.org/5w4n0S15k|archivedate=2011-01-28}}</ref>.

По мере устаревания платформы её поддержка в основной ветви языка прекращается. Например, с серии 2.6 прекращена поддержка [[Windows 95]], [[Windows 98]] и [[Windows ME]]<ref>{{cite web|url=http://docs.python.org/whatsnew/2.6.html#port-specific-changes-windows|title=Port-Specific Changes: Windows|work=Python v2.6.1 documentation. What’s New in Python 2.6|publisher=Python Software Foundation|accessdate=11 декабря 2008 |lang=en |archiveurl=http://www.webcitation.org/5w4n1Glim|archivedate=2011-01-28}}</ref>. Однако на этих платформах можно использовать предыдущие версии Python — на данный момент сообщество активно поддерживает версии Python начиная от 2.3 (для них выходят исправления).

При этом, в отличие от многих портируемых систем, для всех основных платформ Python имеет поддержку характерных для данной платформы технологий (например, Microsoft [[Microsoft Component Object Model|COM]]/[[Microsoft Distributed Component Object Model|DCOM]]). Более того, существует специальная версия Python для [[Виртуальная машина Java|виртуальной машины Java]] — [[Jython]], что позволяет интерпретатору выполняться на любой системе, поддерживающей Java, при этом классы Java могут непосредственно использоваться из Python и даже быть написанными на Python. Также несколько проектов обеспечивают интеграцию с платформой [[Microsoft .NET]], основные из которых — [[IronPython]] и [[Python.Net]].

== Типы и структуры данных ==
Python поддерживает [[динамическая типизация|динамическую типизацию]], то есть тип переменной определяется только во время исполнения. Поэтому вместо «присваивания значения переменной» лучше говорить о «связывании значения с некоторым именем». В Python имеются встроенные типы: [[булевский тип|булевый]], [[строковый тип|строка]], [[Unicode]]-строка, целое число произвольной точности, число [[плавающая запятая|с плавающей запятой]], [[комплексное число]] и некоторые другие. Из [[коллекция (программирование)|коллекций]] в Python встроены: [[список (информатика)|список]], [[кортеж (информатика)|кортеж]] (''неизменяемый список''), [[ассоциативный массив|словарь]], [[множество]] и другие<ref>[http://docs.python.org/library/stdtypes.html Python Documentation — Built-in Types]</ref>. Все значения являются объектами, в том числе функции, методы, модули, классы.

Добавить новый тип можно либо написав [[Класс (программирование)|класс]] (class), либо определив новый тип в модуле расширения (например, написанном на языке C). Система классов поддерживает [[Наследование (программирование)|наследование]] (одиночное и [[множественное наследование|множественное]]) и [[метапрограммирование]]. Возможно наследование от большинства встроенных типов и типов расширений.

Все объекты делятся на ссылочные и атомарные. К атомарным относятся <code>int</code>, <code>long</code> (в версии 3 любое число <code>int</code>, так как в версии 3 нет ограничения на размер), <code>complex</code> и некоторые другие. При присваивании атомарных объектов копируется их значение, в то время как для ссылочных копируется только указатель на объект, таким образом, обе переменные после присваивания используют одно и то же значение. Ссылочные объекты бывают изменяемые и неизменяемые. Например, строки и кортежи являются неизменяемыми, а списки, словари и многие другие объекты — изменяемыми. Кортеж в Python является, по сути, неизменяемым списком. Во многих случаях кортежи работают быстрее списков<ref>[http://stackoverflow.com/questions/68630/are-tuples-more-efficient-than-lists-in-python Are tuples more efficient than lists in Python? — Stack Overflow<!-- Заголовок добавлен ботом -->]</ref>, поэтому если вы не планируете изменять последовательность, то лучше использовать именно их.

== Синтаксис и семантика ==
Язык обладает чётким и последовательным синтаксисом, продуманной модульностью и [[масштабируемость]]ю, благодаря чему исходный код написанных на Python программ легко читаем. При передаче аргументов в функции Python использует [[вызов по соиспользованию]] ({{lang-en2|call-by-sharing}})<ref>{{cite web
| title = Call By Object
| author = Fredrik Lundh
| work = effbot.org
| lang = {{ref-en}}
| url = http://effbot.org/zone/call-by-object.htm
}}</ref>.

{{seealso|:en:Python syntax and semantics}}

=== Операторы ===
Набор операторов достаточно традиционен. Вот некоторые из них:

* условный оператор <code>if</code> (если). Альтернативный блок после <code>else</code> (иначе). Если условий и альтернатив несколько, можно использовать <code>elif</code> (сокр. от else if).
* операторы цикла <code>while</code> (пока) и <code>for</code> (для). Внутри цикла возможно применение <code>break</code> и <code>continue</code> для прерывания цикла и перехода сразу к следующей итерации соответственно.
* оператор определения класса <code>class</code>.
* оператор определения функции, метода или генератора <code>def</code>. Внутри возможно применение <code>return</code> (возврат) для возврата из функции или метода, а в случае генератора — <code>yield</code> (давать).
* оператор обработки исключений <code>try</code> — <code>except</code> — <code>else</code> или <code>try</code> — <code>finally</code> (начиная с версии 2.5, можно использовать <code>finally</code>, <code>except</code> и <code>else</code> в одном блоке).
* оператор <code>pass</code> ничего не делает. Используется для пустых блоков кода.

Одной из интересных синтаксических особенностей языка является выделение [[блок (программирование)|блоков]] кода с помощью отступов (пробелов или табуляций), поэтому в Python отсутствуют [[операторные скобки]] begin/end, как в языке [[Паскаль (язык программирования)|Паскаль]], или фигурные скобки, как в [[Си (язык программирования)|Си]]. Такой «трюк» позволяет сократить количество строк и символов в программе и приучает к «хорошему» стилю программирования. <!-- Если хотите, напишите нормальный тому пример, но не такой, какой был -->С другой стороны, поведение и даже корректность программы может зависеть от начальных пробелов в тексте. Некоторым такое поведение может показаться неинтуитивным и неудобным.

=== Выражения ===
Выражение является полноправным оператором в Python. Состав, синтаксис, ассоциативность и приоритет операций достаточно привычны для языков программирования и призваны минимизировать употребление скобок.

Отдельно стоит упомянуть ''операцию форматирования'' для строк (работает по аналогии с <code>printf()</code> из Си), которая использует тот же символ, что и взятие остатка от деления:
<source lang="python">
>>> print ("Здравствуй, %s!" % "Мир")
Здравствуй, Мир!
</source>
Python имеет удобные ''цепочечные сравнения''. Такие условия в программах — не редкость:
<source lang="python">
1 <= a < 10 and 1 <= b < 20
</source>
Кроме того, логические операции (<code>or</code> и <code>and</code>) являются [[Ленивые вычисления|ленивыми]]: если для вычисления значения операции достаточно первого операнда, этот операнд и является результатом, в противном случае вычисляется второй операнд логической операции. Это основывается на свойствах [[Алгебра логики|алгебры логики]]: например, если один аргумент операции «ИЛИ» (<code>or</code>) является истиной, то и результат этой операции всегда является истиной. В случае, если второй операнд является сложным выражением, это позволяет сократить издержки на его вычисление. Этот факт широко использовался до версии 2.5 вместо условной конструкции:
<source lang="python">
(a < b) and "меньше" or "больше или равно"
</source>
Встроенные типы данных, как правило, имеют особый синтаксис для своих литералов (записанных в исходном коде констант):
<source lang="python">
# для версии меньше 3
"строка" + 'строка' """тоже строка""" u"Юникод-строка"
True or False # булевы литералы
3.14 # число с плавающей запятой
012 + 0xA # числа в восьмеричной и шестнадцатеричной системах счисления
1 + 2j # комплексное число
[1, 2, "a"] # список
(1, 2, "a") # кортеж
{'a': 1, 'b': 'B'} # словарь
{'a', 6, 8.8} # множество
lambda x: x**2 # анонимная функция
# для версии 3
"строка и Юникод-строка одновременно" + 'строка и Юникод-строка одновременно' """тоже строка и Юникод-строка одновременно"""
True or False # булевы литералы
3.14 # число с плавающей запятой
0b1010 + 0o12 + 0xA # числа в двоичной, восьмеричной и шестнадцатеричной системах счисления
1 + 2j # комплексное число
[1, 2, "a"] # список
(1, 2, "a") # кортеж
{'a': 1, 'b': 'B'} # словарь
{'a', 6, 8.8} # множество
lambda x: x**2 # анонимная функция
</source>
Для списков (и других последовательностей) Python предлагает набор операций над срезами. Особенностью является индексация, которая может показаться новичку странной, но раскрывает свою согласованность по мере использования. Индексы элементов списка начинаются с нуля. Запись среза <code>s[N:M]</code> означает, что в срез попадают все элементы от N включительно до M не включая. В качестве иллюстрации можно посмотреть [[v:Примеры программ на языке Python#Примеры работы с последовательностями|пример работы с последовательностями]].

=== Имена ===
Имя (идентификатор) может начинаться с латинской буквы (В Python 3 — буквы любого алфавита в Юникоде, например кириллицы) любого регистра или подчёркивания, после чего в имени можно использовать и цифры. В качестве имени нельзя использовать ключевые слова (их список можно узнать по <code>import keyword; print keyword.kwlist</code>, для версии 3 <code>import keyword; print(keyword.kwlist)</code>) и нежелательно переопределять встроенные имена. Имена, начинающиеся с символа подчёркивания, имеют специальное значение<ref>{{cite web|url=http://docs.python.org/reference/lexical_analysis.html#reserved-classes-of-identifiers|title=2.3.2. Reserved classes of identifiers |work=Python documentation|date=18 октября 2009|archiveurl=http://www.webcitation.org/5w4n2As6O |archivedate=2011-01-28}}</ref>.

В каждой точке программы интерпретатор имеет доступ к трём [[пространство имён (программирование)|пространствам имён]] (то есть отображениям имён в объекты): локальному, глобальному и встроенному.

''Области видимости'' имён могут быть вложенными друг в друга (внутри определяемой функции видны имена из окружающего блока кода). На практике с областями видимости и связыванием имён связано несколько правил «хорошего тона», о которых можно подробнее узнать из документации.

=== Строки документации ===
Python предлагает механизм [[Техническая документация|документирования]] кода pydoc. В начало каждого модуля, класса, функции вставляется строка документации — ''{{не переведено|:en:docstring|docstring}}''. Строки документации остаются в коде на момент времени исполнения, и в язык встроен доступ к документации<ref>[http://softwaremaniacs.org/blog/2005/12/08/django/ …целостность больших проектов на Python строится на двух вещах: тесты и doc-строка]</ref>(переменная <code>__doc__</code>), что используется современными IDE (например, [[Eclipse (среда разработки)|Eclipse]]).

В интерактивном режиме можно получить помощь, сгенерировать гипертекстовую документацию по целому модулю или даже применить ''{{не переведено|:en:doctest|doctest}}'' для автоматического тестирования модуля.

=== Директивы ===
Начиная с Python 2.3, для использования в тексте программы символов, не входящих в ASCII, необходимо явно указывать кодировку исходного кода в начале модуля, например:
<source lang="python">
# -*- coding: utf-8 -*-
# или
# coding: utf-8
</source>
После этого можно использовать, например, кириллицу в Unicode-литералах. Но на самом деле, даже если вы напишете:
<source lang="python">
# coding: utf
</source>
То Python «поймёт», что вы хотели сделать.

== Возможности ==

=== Интерактивный режим ===
Подобно [[Лисп]]у и [[Пролог (язык программирования)|Прологу]] в режиме отладки, интерпретатор Python имеет интерактивный режим работы, при котором введённые с клавиатуры операторы сразу же выполняются, а результат выводится на экран ([[REPL]]). Этот режим интересен не только новичкам, но и опытным программистам, которые могут протестировать в интерактивном режиме любой участок кода, прежде чем использовать его в основной программе, или просто использовать как [[калькулятор]] с большим набором функций.

Так выглядит общение с Python в интерактивном режиме:
<source lang="python">
>>> 2 ** 100 # возведение 2 в степень 100
1267650600228229401496703205376L
>>> from math import * # импорт математических функций
>>> sin(pi * 0.5) # вычисление синуса от половины пи 
1.0
>>> help(sorted) # помощь по функции sorted
Help on built-in function sorted in module __builtin__:
sorted(...)
   sorted(iterable, cmp=None, key=None, reverse=False) --> new sorted list
</source>
В интерактивном режиме доступен [[отладчик]] <code>pdb</code> и система помощи (вызывается по <code>help()</code>). Система помощи работает для модулей, классов и функций, только если те были снабжены строками документации.

Кроме встроенной, существуют и улучшенные интерактивные оболочки [[IPython]]<ref>http://ipython.scipy.org/</ref> и [[bpython]]<ref>[http://www.bpython-interpreter.org/ bpython interpreter<!-- Заголовок добавлен ботом -->]</ref>.

=== Объектно-ориентированное программирование ===
{{main|Объектно-ориентированное программирование на Python}}
Дизайн языка Python построен вокруг объектно-ориентированной модели программирования. Реализация [[Объектно-ориентированное программирование|ООП]] в Python является элегантной, мощной и хорошо продуманной, но вместе с тем достаточно специфической по сравнению с другими [[Объектно-ориентированный язык программирования|объектно-ориентированными языками]].

Возможности и особенности:
# Классы являются одновременно объектами со всеми ниже приведёнными возможностями.
# Наследование, в том числе множественное.
# Полиморфизм (все функции виртуальные).
# Инкапсуляция (два уровня — общедоступные и скрытые методы и поля). Особенность — скрытые члены доступны для использования и помечены как скрытые лишь особыми именами.
# Специальные методы, управляющие жизненным циклом объекта: конструкторы, деструкторы, распределители памяти.
# Перегрузка операторов (всех, кроме <code>is, '.', '='</code> и символьных логических).
# Свойства (имитация поля с помощью функций).
# Управление доступом к полям (эмуляция полей и методов, частичный доступ, и т. п.).
# Методы для управления наиболее распространёнными операциями (истинностное значение, <code>len()</code>, глубокое копирование, [[сериализация]], итерация по объекту, …)
# Метапрограммирование (управление созданием классов, триггеры на создание классов, и др.)
# Полная [[Интроспекция (программирование)|интроспекция]].
# Классовые и статические методы, классовые поля.
# Классы, вложенные в функции и классы.

=== Функциональное программирование ===
{{main|Функциональное программирование на Python}}
Python поддерживает парадигму [[функциональное программирование|функционального программирования]], в частности:

* функция является объектом
* функции высших порядков
* рекурсия
* развитая обработка списков (списочные выражения, операции над последовательностями, итераторы)
* аналог замыканий
* частичное применение функции
* возможность реализации других средств на самом языке (например, [[карринг]])

=== Модули и пакеты ===
Программное обеспечение (приложение или библиотека) на Python оформляется в виде [[Модуль (программирование)|модулей]], которые в свою очередь могут быть собраны в ''пакеты''. Модули могут располагаться как в [[Каталог (файловая система)|каталогах]], так и в [[ZIP|ZIP-архивах]]. Модули могут быть двух типов по своему происхождению: модули, написанные на «чистом» Python, и модули расширения (extension modules), написанные на других языках программирования. Например, в стандартной библиотеке есть «чистый» модуль pickle и его аналог на Си: cPickle. Модуль оформляется в виде отдельного файла, а пакет — в виде отдельного каталога. Подключение модуля к программе осуществляется оператором <code>import</code>. После импорта модуль представлен отдельным объектом, дающим доступ к пространству имён модуля. В ходе выполнения программы модуль можно перезагрузить функцией <code>reload()</code>.

=== Интроспекция ===
{{main|Интроспекция в Python}}
Python поддерживает полную [[Интроспекция (программирование)|интроспекцию]] времени исполнения. Это означает, что для любого объекта можно получить всю информацию о его внутренней структуре.

Применение интроспекции является важной частью того, что называют [[pythonic style]], и широко применяется в библиотеках и [[фреймворк]]ах Python, таких как PyRO, PLY, Cherry, [[Django]] и др., значительно экономя время использующего их программиста.

=== Обработка исключений ===
[[Обработка исключений]] поддерживается в Python посредством операторов <code>try, except, else, finally, raise</code>, образующих блок обработки исключения. В общем случае блок выглядит следующим образом:
<source lang="python">
try:
    # Здесь код, который может вызвать исключение
    raise Exception("message")  # Exception, это один из стандартных типов исключения (всего лишь класс),
                                # может использоваться любой другой, в том числе свой
except (Тип исключения1, Тип исключения2, …) as Переменная:
    # Код в блоке выполняется, если тип исключения совпадает с одним из типов
    # (Тип исключения1, Тип исключения2, …) или является наследником одного
    # из этих типов.
    # Полученное исключение доступно в необязательной Переменной.
except (Тип исключения3, Тип исключения4, …) as Переменная:
    # Количество блоков except не ограничено
    raise  # Сгенерировать исключение "поверх" полученного; без параметров - повторно сгенерировать полученное
except:
    # Будет выполнено при любом исключении, не обработанном типизированными блоками except
else:
    # Код блока выполняется, если не было поймано исключений.
finally:
    # Будет исполнено в любом случае, возможно после соответствующего
    # блока except или else
</source>
Совместное использование <code>else, except</code> и <code>finally</code> стало возможно только начиная с Python 2.5. Информация о текущем исключении всегда доступна через <code>sys.exc_info()</code>. Кроме значения исключения, Python также сохраняет состояние стека вплоть до точки возбуждения исключения — так называемый traceback.

В отличие от компилируемых языков программирования, в Python использование исключения не приводит к значительным накладным расходам (а зачастую даже позволяет ускорить исполнение программ) и очень широко используется. Исключения согласуются с философией Python (10-й пункт «[[#Философия|дзена Python]]» — «Ошибки никогда не должны умалчиваться») и являются одним из средств поддержки «[[Утиная типизация|утиной типизации]]».

Иногда вместо явной обработки исключений удобнее использовать блок [[Python#Управление контекстом выполнения|<code>with</code>]] (доступен, начиная с Python 2.5).

=== Итераторы ===
В программах на Python широко используются [[Итератор (программирование)|итераторы]]. Цикл <code>for</code> может работать как с последовательностью, так и с итератором. Все коллекции, как правило, предоставляют итератор. Объекты определённого пользователем класса тоже могут быть итераторами. Подробнее об итераторах можно узнать [[Функциональное программирование на Питоне#Итераторы|в разделе о функциональном программировании]]. Модуль <code>itertools</code> стандартной библиотеки содержит много полезных функций для работы с итераторами.

=== Генераторы ===
Одной из интересных возможностей языка являются '''генераторы''' — функции, сохраняющие внутреннее состояние: значения локальных переменных и текущую инструкцию (см. также: [[сопрограмма|сопрограммы]]). Генераторы могут использоваться как [[Итератор (программирование)|итераторы]] для структур данных и для [[ленивые вычисления|ленивых вычислений]]. См. пример: [[v:Примеры программ на языке Python#Генератор чисел Фибоначчи|генератор чисел Фибоначчи]].

При вызове генератора функция немедленно возвращает объект-итератор, который хранит текущую точку исполнения и состояние локальных переменных функции. При запросе следующего значения (посредством метода <code>next()</code>, неявно вызываемого в цикле <code>for</code>) генератор продолжает исполнение функции от предыдущей точки останова до следующего оператора <code>yield</code> или <code>return</code>.

В Python 2.4 появились '''генераторные выражения''' — выражения, дающие в результате генератор. Генераторные выражения позволяют сэкономить память там, где иначе требовалось бы использовать список с промежуточными результатами:
<source lang="python">
>>> sum(i for i in xrange(1, 100) if i % 2 != 0)
2500
</source>
В этом примере суммируются все нечётные числа от 1 до 99.

Начиная с версии 2.5, Python поддерживает полноценные сопроцедуры: теперь в генератор можно передавать значения с помощью метода <code>send()</code> и возбуждать в его контексте исключения с помощью метода <code>throw()</code>.

=== Управление контекстом выполнения ===
В Python 2.5 появились средства для управления контекстом выполнения блока кода — оператор <code>with</code> и модуль <code>contextlib</code>. См.: [[v:Примеры программ на языке Python#Управление контекстом выполнения|пример]].

Оператор может применяться в тех случаях, когда до и после некоторых действий должны обязательно выполняться некоторые другие действия, независимо от возбуждённых в блоке исключений или операторов <code>return</code>: файлы должны быть закрыты, ресурсы освобождены, перенаправление стандартного ввода вывода закончено и т. п. Оператор улучшает читаемость кода, а значит, помогает предотвращать ошибки.

=== Декораторы ===
Начиная с версии 2.4, Python позволяет использовать т. н. ''декораторы''<ref>[http://www.python.org/dev/peps/pep-0318/ PEP318]</ref> (не следует путать с [[Декоратор (шаблон проектирования)|одноимённым]] [[Шаблоны проектирования|шаблоном проектирования]]) для поддержки существующей практики преобразования функций и методов в месте определения (декораторов может быть несколько). Для декораторов используется символ <code>@</code> в строках, предшествующих определению функции или метода. Синтаксис декорирования является [[синтаксический сахар|синтаксическим сахаром]] для удобочитаемости: код
<source lang="python">
@staticmethod
def myWonderfulMethod():
    return "Некоторый метод"
</source>
полностью эквивалентен
<source lang="python">
def myWonderfulMethod():
    return "Некоторый метод"
myWonderfulMethod = staticmethod(myWonderfulMethod)
</source>
Сам декоратор является функцией, получающей в качестве первого аргумента декорируемую функцию. Для передачи дополнительных аргументов можно использовать синтаксис <code>@декоратор(аргументы)</code>. Декораторы можно считать элементом [[аспектно-ориентированное программирование|аспектно-ориентированного программирования]].

С версии 2.6 декораторы можно использовать с классами аналогично функциям.

=== Другие возможности ===
<!-- наверно, тут тоже нужно сделать один пример и его в примеры перенести -->
В Python есть ещё несколько возможностей, отличающих его от многих других языков высокой гибкостью и динамичностью.

Например, класс является объектом, а в операторе определения класса можно использовать выражения в списке родительских классов.
<source lang="python">
def getClass():
    return dict
class D(getClass()):
    pass
d = D()
</source>
Можно модифицировать многие объекты во время исполнения, например классы:
<source lang="python">
>>> class X(object): pass
…
>>> y = X()
>>> y.wrongMethod() # такого метода пока нет
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'X' object has no attribute 'wrongMethod'
>>> X.wrongMethod = lambda self : 'im here' # добавим его
>>> y.wrongMethod() # так как доступ к методу приводит к поиску по __dict__ класса,
'im here' # то wrongMethod становится доступным всем экземплярам
</source>

== Библиотеки ==

=== Стандартная библиотека ===
{{main|Стандартная библиотека Python}}
[[Файл:Python batteries included.jpg|thumb| Python поставляется «[[Стандартная библиотека Python|с батарейками в комплекте]]».]]

Богатая стандартная [[Библиотека (программирование)|библиотека]] является одной из привлекательных сторон Python. Здесь имеются средства для работы со многими [[Сетевой протокол|сетевыми протоколами]] и форматами [[Интернет]]а, например, модули для написания [[HTTP-сервер]]ов и клиентов, для разбора и создания почтовых сообщений, для работы с [[XML]] и т. п. Набор модулей для работы с [[операционная система|операционной системой]] позволяет писать кросс-платформенные приложения. Существуют модули для работы с [[регулярное выражение|регулярными выражениями]], текстовыми [[кодировка]]ми, [[мультимедиа|мультимедийными]] форматами, [[криптография|криптографическими]] протоколами, архивами, [[Сериализация|сериализации]] данных, поддержка [[Юнит-тестирование|юнит-тестирования]] и др.

=== Модули расширения и программные интерфейсы ===
Помимо стандартной библиотеки существует множество библиотек, предоставляющих интерфейс ко всем системным вызовам на разных платформах; в частности, на платформе Win32 поддерживаются все вызовы [[Win32 API]], а также [[Component Object Model|COM]] в объёме не меньшем, чем у [[Visual Basic]] или [[Delphi (язык программирования)|Delphi]]. Количество прикладных библиотек для Python в самых разных областях без преувеличения огромно ([[Всемирная паутина|веб]], [[База данных|базы данных]], обработка изображений, обработка текста, [[численные методы]], приложения [[операционная система|операционной системы]] и т. д.).

Для Python принята спецификация программного интерфейса к базам данных [[DB-API 2]] и разработаны соответствующие этой спецификации пакеты для доступа к различным [[СУБД]]: [[Oracle Database|Oracle]], [[MySQL]], [[PostgreSQL]], [[Sybase]], [[Firebird]] ([[Interbase]]), [[Informix]], [[Microsoft SQL Server]] и [[SQLite]]. На платформе [[Windows]] доступ к БД возможен через [[ADO]] ([[ADOdb]]). Коммерческий пакет mxODBC для доступа к СУБД через [[ODBC]] для платформ Windows и [[UNIX]] разработан eGenix<ref>[http://egenix.com/ eGenix.com — Professional Python Software, Skills and Services<!-- Заголовок добавлен ботом -->]</ref>. Для Python написано много [[ORM]] ([[SQLObject]], [[SQLAlchemy]], Dejavu, [[Django]]), выполнены программные каркасы для разработки веб-приложений ([[Django]], [[Pylons]], [[Pyramid (программный каркас)|Pyramid]]).

Библиотека [[NumPy]] для работы с многомерными [[массив (программирование)|массивами]] позволяет достичь производительности научных расчётов, сравнимой со специализированными пакетами. [[SciPy]] использует NumPy и предоставляет доступ к обширному спектру математических алгоритмов (матричная алгебра — [[BLAS]] уровней 1—3, [[LAPACK]], [[Быстрое преобразование Фурье|БПФ]]…). Numarray<ref>[http://www.stsci.edu/resources/software_hardware/numarray numarray Home Page<!-- Заголовок добавлен ботом -->]</ref> специально разработан для операций с большими объёмами научных данных.

[[WSGI]]<ref>[http://www.python.org/dev/peps/pep-0333/ PEP333]</ref> — интерфейс шлюза с веб-сервером (Python Web Server Gateway Interface).

Python предоставляет простой и удобный программный интерфейс [[C API]] для написания собственных модулей на языках [[Си (язык программирования)|Си]] и [[C++]]. Такой инструмент как [[SWIG]] позволяет почти автоматически получать привязки для использования C/C++ библиотек в коде на Python. Возможности этого и других инструментов варьируются от автоматической генерации (C/C++/Fortran)-Python интерфейсов по специальным файлам (SWIG, pyste<ref>[http://www.boost.org/libs/python/pyste/index.html Pyste Documentation<!-- Заголовок добавлен ботом -->]</ref>, SIP<ref>http://www.riverbankcomputing.co.uk/sip/</ref>, pyfort<ref>http://pyfortran.sourceforge.net/</ref>), до предоставления более удобных API (boost::python<ref>[http://www.boost.org/libs/python/doc/ Boost.Python<!-- Заголовок добавлен ботом -->]</ref>, CXX<ref>[http://cxx.sourceforge.net/ PyCXX: Write Python Extensions in C<!-- Заголовок добавлен ботом -->]</ref>, Pyhrol<ref>[http://pyhrol.ru/ Мост между C++ и Python]</ref> и др.). Инструмент стандартной библиотеки [[ctypes]] позволяет программам Python напрямую обращаться к [[динамическая библиотека|динамическим библиотекам]]/[[DLL]], написанным на Си. Существуют модули, позволяющие встраивать код на С/C++ прямо в исходные файлы Python, создавая расширения «на лету» (pyinline<ref>[http://pyinline.sourceforge.net/ PyInline: Mix Other Languages directly Inline with your Python<!-- Заголовок добавлен ботом -->]</ref>, weave<ref>[http://www.scipy.org/Weave Weave<!-- Заголовок добавлен ботом -->]</ref>).

Другой подход состоит во встраивании интерпретатора Python в приложения. Python легко встраивается в программы на Java, C/C++, [[Ocaml]]. Взаимодействие Python-приложений с другими системами возможно также с помощью [[CORBA]], [[XML-RPC]], [[SOAP]], COM.

С помощью проекта [[Cython]] возможна трансляция программ написанных на языках Python и {{translation|:en:Pyrex (programming language)|Pyrex}} в код на языке Си, с последующей компиляцией в машинный код. Cython используется для упрощения написания Python-библиотек, при его использовании отмечается ускорение кода и уменьшение накладных расходов.

Экспериментальный проект [[Shedskin]] предполагает создание компилятора для трансформации неявно типизированных Python программ в оптимизированный С++ код. Начиная с версии 0.22 Shedskin позволяет компилировать отдельные функции в модули расширений.

Python и подавляющее большинство библиотек к нему бесплатны и поставляются в исходных кодах. Более того, в отличие от многих открытых систем, лицензия никак не ограничивает использование Python в коммерческих разработках и не налагает никаких обязательств кроме указания авторских прав.

Одним из каналов распространения и обновления пакетов для Python является [[PyPI]] ({{lang-en|Python Package Index}}).

=== Графические библиотеки ===
С Python поставляется библиотека [[tkinter]] на основе [[Tcl]]/[[Tk]] для создания кроссплатформенных программ с [[GUI|графическим интерфейсом]].

Существуют расширения, позволяющие использовать все основные библиотеки графических интерфейсов — [[wxPython]]<ref>[http://www.wxpython.org/ wxPython<!-- Заголовок добавлен ботом -->]</ref>, основанное на библиотеке [[wxWidgets]], [[PyGTK]] для [[Gtk]], [[PyQt]] и [[PySide]] для [[Qt]] и другие. Некоторые из них также предоставляют широкие возможности по работе с базами данных, графикой и сетями, используя все возможности библиотеки, на которой основаны.

Для создания игр и приложений, требующих нестандартного интерфейса, можно использовать библиотеку [[Pygame]]. Она также предоставляет обширные средства работы с [[мультимедиа]]: с её помощью можно управлять звуком и изображениями, воспроизводить видео. Предоставляемое pygame аппаратное ускорение графики [[OpenGL]] имеет более высокоуровневый интерфейс по сравнению с PyOpenGL<ref>[http://pyopengl.sourceforge.net/ PyOpenGL — The Python OpenGL Binding<!-- Заголовок добавлен ботом -->]</ref>, копирующей семантику С-библиотеки для OpenGL. Есть также PyOgre<ref>[http://www.ogre3d.org/wiki/index.php/PyOgre PyOgre : Ogre Wiki<!-- Заголовок добавлен ботом -->]</ref>, обеспечивающая привязку к [[Ogre]] — высокоуровневой объектно-ориентированной библиотеке 3D-графики. Кроме того, существует библиотека pythonOCC<ref>[http://www.pythonocc.org/ pythonOCC, 3D CAD/CAE/PLM development framework for the Python programming language<!-- Заголовок добавлен ботом -->]</ref>, обеспечивающая привязку к среде 3D-моделирования и симуляции OpenCascade<ref>[http://www.opencascade.org/ Open CASCADE Technology, 3D modeling & numerical simulation<!-- Заголовок добавлен ботом -->]</ref>.

Для работы с [[Растровая графика|растровой графикой]] используется библиотека [[Python Imaging Library]].

=== Контроль типов и перегрузка функций ===
Существуют модули, позволяющие контролировать типы параметров функций на этапе исполнения, например, typecheck<ref>[http://oakwinter.com/code/typecheck/ Typechecking module for Python<!-- Заголовок добавлен ботом -->]</ref> или method signature checking decorators<ref>[http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/426123 Method signature checking decorators " Python recipes " ActiveState Code<!-- Заголовок добавлен ботом -->]</ref>. Необязательная декларация типов для параметров функции добавлена в Python 3, интерпретатор при этом не проверяет типы, а только добавляет соответствующую информацию к метаданным функции для последующего использования этой информации модулями расширений.<ref name="pep-3107">[http://www.python.org/dev/peps/pep-3107/ PEP-3107]</ref>

Перегрузка функций реализована различными сторонними библиотеками, в том числе PEAK<ref>[http://peak.telecommunity.com/DevCenter/FrontPage FrontPage — The PEAK Developers' Center<!-- Заголовок добавлен ботом -->]</ref><ref>[http://peak.telecommunity.com/DevCenter/RulesReadme PEAK-Rules]</ref>. Не принятые планы по поддержке перегрузки в Python3000<ref>[http://www.python.org/dev/peps/pep-3124/ PEP-3124]</ref> были частично реализованы в библиотеке overloading-lib<ref>[http://code.google.com/p/overloading-lib/ overloading-lib], Библиотека динамической перегрузки функций и методов основанной на типах аргументов для языка python</ref>.

== Примеры программ ==
В статье «[[v:Примеры программ на языке Python|Примеры программ на языке Python]]» собраны примеры небольших программ, демонстрирующих некоторые возможности языка Python и его стандартной библиотеки.

== Профилирование и оптимизация кода ==
В стандартной библиотеке Python имеется [[Профилирование (информатика)|профайлер]] (модуль '''profile'''), который можно использовать для сбора статистики о времени работы отдельных функций. Для решения вопроса о том, какой вариант кода работает быстрее, можно использовать модуль <code>timeit</code>. Производимые в следующей программе измерения позволяют выяснить, какой из вариантов [[Конкатенация|конкатенации]] строк более эффективен:
<source lang="python">
from timeit import Timer

tmp = "Python 3.2.2 (default, Jun 12 2011, 15:08:59) [MSC v.1500 32 bit (Intel)] on win32."

def case1(): # А. инкрементальные конкатенации в цикле
    s = ""
    for i in range(10000):
        s += tmp

def case2(): # Б. через промежуточный список и метод join
    s = []
    for i in range(10000):
        s.append(tmp)
    s = "".join(s)

def case3(): # В. списковое выражение и метод join
    return "".join([tmp for i in range(10000)])

def case4(): # Г. генераторное выражение и метод join
    return "".join(tmp for i in range(10000))

for v in range(1,5):
    print (Timer("func()","from __main__ import case%s as func" % v).timeit(200))
</source>
Как и в любом языке программирования, в Python имеются свои приёмы [[оптимизация (информатика)|оптимизации]] кода. Оптимизировать код можно исходя из различных (часто конкурирующих друг с другом) критериев (увеличение быстродействия, уменьшение объёма требуемой оперативной памяти, компактность исходного кода и т. д.). Чаще всего программы оптимизируют по времени исполнения.

Здесь есть несколько очевидных правил:

* Не нужно оптимизировать программу, если скорость её выполнения достаточна.
* Используемый алгоритм имеет определённую [[Временная сложность алгоритма|временную сложность]], поэтому перед оптимизацией кода программы стоит сначала пересмотреть алгоритм.
* Стоит использовать готовые и отлаженные функции и модули, даже если для этого нужно немного обработать данные. Например, в Python есть встроенная функция '''sort()'''.
* Профилирование поможет выяснить узкие места. Оптимизацию нужно начинать с них.

Python имеет следующие особенности и связанные с ними правила оптимизации:

* Вызов функций является достаточно дорогостоящей операцией, поэтому внутри вложенных циклов нужно стараться избегать вызова функций или, например, переносить цикл в функции. Функция, обрабатывающая последовательность, эффективнее, чем обработка той же последовательности в цикле вызовом функции.
* Старайтесь вынести из глубоко вложенного цикла всё, что можно вычислить во внешних циклах. Доступ к локальным переменным более быстрый, чем к глобальным, или чем доступ к полям.
* Оптимизатор '''psyco''' может помочь ускорить работу модуля программы при условии, что модуль не использует динамических свойств языка Python.
* В случае, если модуль проводит массированную обработку данных и оптимизация алгоритма и кода не помогает, можно переписать [[Критический участок кода|критические участки]], скажем, на языке Си или Pyrex.

Инструмент под названием Pychecker<ref>[http://pychecker.sourceforge.net/ PyChecker: a python source code checking tool<!-- Заголовок добавлен ботом -->]</ref> поможет проанализировать исходный код на Python и выдать рекомендации по найденным проблемам (например, неиспользуемые имена, изменение сигнатуры метода при его перегрузке и т. п.). В ходе такого статического анализа исходного кода могут быть выявлены и ошибки. Pylint<ref>[http://www.logilab.org/view?rql=Any%20X%20WHERE%20X%20eid%20857 pylint (analyzes Python source code looking for bugs and signs of poor quality.) (Logilab.org)<!-- Заголовок добавлен ботом -->]</ref> призван решать близкие задачи, но имеет уклон в сторону проверки стиля кода, поиска [[код с запашком|кода с запашком]]<ref>[http://docs.pylint.org/intro.html Pylint 1.0.0 documentation, Introduction]</ref>.

== Сравнение с другими языками ==
Наиболее часто Python сравнивают с [[Perl]] и [[Ruby]]. Эти языки также являются [[Интерпретируемый язык программирования|интерпретируемыми]] и обладают примерно одинаковой скоростью выполнения программ. Как и Perl, Python может успешно применяться для написания скриптов (сценариев). Как и Ruby, Python является хорошо продуманной системой для [[Объектно-ориентированное программирование|ООП]].

Средства [[функциональное программирование|функционального программирования]] частично позаимствованы из [[Scheme]] и [[Icon (язык программирования)|Icon]].

В среде коммерческих приложений скорость выполнения программ на Python часто сравнивают с [[Java]]-приложениями<ref>[http://shootout.alioth.debian.org/ Результаты одной из попыток сравнения]</ref>.

Несмотря на то, что Python обладает достаточно самобытным синтаксисом, одним из принципов дизайна этого языка является [[Правило наименьшего удивления|принцип наименьшего удивления]].
<!--
В отличие от некоторых ООЯП ([[Java]], [[Object Pascal]], [[Ruby]], …) в Python нет общего базового класса (обычно называется <code>object</code>). Все «новые» классов наследуют (прямо или косвенно) тип <code>object</code>, но он является только синтаксическим приёмом создания «нового» класса и не несёт функциональной нагрузки. В следствии этого многие методы, которые являются общими для всех объектов — <code>id, type, isinstance, issubclass, str, repr, getattr, …</code> реализованы в виде глобальных функций, а не в виде перегружаемых наследуемых методов <code>object</code>. Наличие этой особенности несколько сглаживается [[утиная типизация|утиной типизацией]] и тем что вызовы (почти всех) этих функций перенаправляются в специальные методы классов, если таковые имеются, что позволяет перегружать их поведение. Например — <code>len(x) => x.__len__()</code>.
-->

=== Недостатки ===

См. также список распространённых недоразумений при использовании языка Python<ref>[https://web.archive.org/web/20130810230937/http://zephyrfalcon.org/labs/python_pitfalls.html zephyrfalcon.org :: labs :: 10 Python pitfalls<!-- Заголовок добавлен ботом -->]</ref>.

==== Низкое быстродействие ====
Классический Python, как и многие другие [[Интерпретируемый язык программирования|интерпретируемые языки]], не применяющие, например, [[JIT]]-компиляторы, имеют общий недостаток — сравнительно невысокую скорость выполнения программ<ref name="alioth-benchmark">{{cite web|url=http://shootout.alioth.debian.org/u32/benchmark.php?test=all&lang=python&lang2=gpp&box=1|title=Python / C++ GNU g++|work=Computer Language Benchmarks Game|publisher=???|accessdate=1 июля 2009|archiveurl=http://www.webcitation.org/5w4n30Deb|archivedate=2011-01-28}}</ref>. Сохранение [[байт-код]]а (расширения <code>.pyc</code> и <code>.pyo</code>, начиная с версии 3.5 расширения <code>.pyo</code> больше нет) позволяет интерпретатору не тратить лишнее время на перекомпиляцию кода модулей при каждом запуске. Кроме того, существует специальная JIT-библиотека psyco<ref>[http://psyco.sf.net/ Psyco]{{ref-en}} — JIT-компилятор для Python, позволяющий увеличить скорость работы программ в 3-10 раз</ref>, позволяющая ускорить выполнение программ (однако приводящая к увеличению потребления оперативной памяти). Эффективность psyco сильно зависит от архитектуры программы.

Существуют реализации языка Python, вводящие высокопроизводительные виртуальные машины (ВМ) в качестве бэк-энда компилятора. Примерами таких реализаций может служить [[PyPy]], базирующийся на LLVM; более ранней инициативой является проект [[Parrot]]. Ожидается, что использование ВМ типа LLVM приведёт к тем же результатам, что и использование аналогичных подходов для реализаций языка Java, где низкая вычислительная производительность в основном преодолена<ref name="unladen-swallow">{{cite web|url=http://code.google.com/p/unladen-swallow/wiki/ProjectPlan|title=unladen-swallow. A faster implementation of Python|publisher=code.google|accessdate=22 июня 2009|quote=Goals: … Produce a version of Python at least 5x faster than CPython|archiveurl=http://www.webcitation.org/5w4n3soB7|archivedate=2011-01-28}}</ref>.

Множество программ/библиотек для интеграции с другими языками программирования (см. выше) предоставляют возможность использовать другой язык для написания критических участков.

В самой популярной реализации языка Python интерпретатор довольно велик и более требователен к ресурсам, чем в аналогичных популярных реализациях [[Tcl]], [[Forth]], [[LISP]] или [[Lua]], что ограничивает его применение во встроенных системах. Тем не менее, Python нашёл применение в [[Карманный персональный компьютер|КПК]] и некоторых моделях мобильных телефонов<ref name="PyS60">[http://wiki.opensource.nokia.com/projects/PyS60 Python for S60 — OpenSource<!-- Заголовок добавлен ботом -->]</ref>.

==== Невозможность модификации встроенных классов ====
По сравнению с [[Ruby]] и некоторыми другими языками, в Python отсутствует возможность модифицировать встроенные классы, такие, как <code>int, str, float, list</code> и другие, что, однако, позволяет Python потреблять меньше оперативной памяти и быстрее работать. Ещё одной причиной введения такого ограничения является необходимость согласования с модулями расширения. Многие модули (в целях оптимизации быстродействия) преобразуют Python-объекты элементарных типов к соответствующим Си-типам вместо манипуляций с ними посредством Си-API. Также это избавляет от многих потенциальных ошибок при неконтролируемом динамическом переопределении встроенных типов.

==== Глобальная блокировка интерпретатора (GIL) ====
{{main|Global Interpreter Lock}}

GIL (Global Interpreter Lock) — особенность, присущая [[CPython]], [[Stackless Python|Stackless]] и [[PyPy]], но отсутствующая в [[Jython]] и [[IronPython]]. При своей работе основной интерпретатор Python постоянно использует большое количество потоко-небезопасных данных. В основном это словари, в которых хранятся атрибуты объектов, и обращения к внешнему коду (написанному на С и т. п.). Во избежание разрушения этих данных при совместной модификации из разных потоков, перед началом исполнения нескольких инструкций (по умолчанию 100) поток интерпретатора захватывает GIL, а по окончании освобождает. Вследствие этого, в каждый момент времени в одном процессе интерпретатора Python может исполняться только один поток кода на Python, даже если в компьютере имеется несколько процессоров или процессорных ядер (GIL также освобождается на время выполнения блокирующих операций, таких как ввод-вывод, изменения/проверка состояния синхронизирующих примитивов и других — таким образом, если один поток блокируется, другие могут исполняться). Была предпринята попытка перехода к более гранулированным синхронизациям, однако из-за частых захватов/освобождений блокировок эта реализация оказалась слишком медленной на однопоточных приложениях<ref>[http://www.artima.com/weblogs/viewpost.jsp?thread=211200 Python 3000 FAQ<!-- Заголовок добавлен ботом -->]</ref>. В ближайшем будущем переход от GIL к другим техникам не предполагается по причине того, что, по мнению автора языка Python Гвидо Россума, однопоточных программ, ускоряемых GIL, больше, чем многопоточных, которые GIL тормозит. Однако есть python-safethread<ref name="google-safethread">[http://code.google.com/p/python-safethread/ python-safethread — Project Hosting on Google Code<!-- Заголовок добавлен ботом -->]</ref> — CPython без GIL и с некоторыми другими изменениями (по утверждениям его авторов, на однопоточных приложениях скорость соответствует 60-65 % от скорости оригинального CPython).

Эта проблема имеет два основных варианта решения. Первый — отказ от совместного использования изменяемых данных и вызовов внешнего кода. При этом данные дублируются в потоках и необходимость обеспечения их синхронизации (если таковая нужна) лежит на программисте<ref>[http://perldoc.perl.org/perlthrtut.html perlthrtut — perldoc.perl.org<!-- Заголовок добавлен ботом -->]</ref>. Этот подход ведёт к увеличению потребления оперативной памяти (однако не настолько сильно, как при использовании процессов в Windows — так как для Unix это не критично, процессы небольшие). <!-- стиль неэнциклопедичен, стоит поправить -->

Второй подход — обеспечение более гранулированной синхронизации — для отдельных структур данных. В этом случае падает производительность вследствие увеличения числа освобождений/захватов блокировок.

Если необходимо параллельное исполнение нескольких потоков кода на Python, то можно воспользоваться процессами, например, модулем processing<ref>[http://pypi.python.org/pypi/processing Python Package Index : processing 0.52<!-- Заголовок добавлен ботом -->]</ref>, который имитирует семантику стандартного модуля threading, но использует процессы вместо потоков. Начиная с версии 2.6, модуль processing добавлен в стандартную библиотеку и переименован в multiprocessing. Есть множество модулей, упрощающих написание параллельных и/или распределённых приложений на Python, таких как parallelpython<ref>[http://www.parallelpython.com/ Parallel Python — Home<!-- Заголовок добавлен ботом -->]</ref>, Pypar<ref>http://datamining.anu.edu.au/~ole/pypar/</ref>, pympi<ref>[http://pympi.sourceforge.net/ pyMPI.sourceforge.net: Putting the py in MPI<!-- Заголовок добавлен ботом -->]</ref> и других. GIL освобождается при исполнении кода большинства расширений, например, [[NumPy]]/[[SciPy]], позволяя во время расчётов исполняться другому потоку. Другим решением может быть использование IronPython или Jython, лишённых этой особенности классического Python.

В версии 3.2 был внедрён изменённый GIL<ref>[http://docs.python.org/dev/whatsnew/3.2.html#multi-threading What’s New In Python 3.2 — Python v3.2b2 documentation<!-- Заголовок добавлен ботом -->]</ref><ref>[http://mail.python.org/pipermail/python-dev/2009-October/093321.html [Python-Dev&#93; Reworking the GIL<!-- Заголовок добавлен ботом -->]</ref>. Основные нововведения:
* Переключение по таймауту, а не по количеству опкодов — в предыдущей версии GIL освобождался через каждые 100 операций. Но операция может выполняться от наносекунд, до долей секунд. В новой версии блокировка будет сниматься каждые 5 миллисекунд;
* Уменьшение накладных расходов и увеличение эффективности в случае частых переключений — в некоторых системах (в основном в [[MacOS X]]) наблюдаются проблема с эффективностью блокировки, когда GIL уже захвачен: системные вызовы становятся дорогими. В новой версии задержки будут уменьшены;
* Уменьшение задержек при переключении потоков благодаря введению механизма принудительного переключения потока и приоритетных запросов (когда поток выполняет приоритетный запрос, то GIL освобождается как можно быстрее).

== Реализации ==

[[CPython]] является основной, но не единственной реализацией языка программирования Python. Существуют также следующие реализации:

[[Jython]] — реализация Python, использующая [[JVM]] в качестве среды исполнения. Позволяет прозрачно использовать [[Java]]-библиотеки.<ref>[http://www.jython.org/ The Jython Project<!-- Заголовок добавлен ботом -->]</ref>

[[Python for S60|PyS60]]<ref name="PyS60"/> — реализация языка для [[смартфон]]ов фирмы [[Nokia]] на платформе [[Symbian S60|Series 60]].

[[IronPython]] — Python для [[.NET Framework]] и [[Mono]]. Компилирует Python программы в [[MSIL]], таким образом предоставляя полную интеграцию с .NET-системой<ref>[http://www.codeplex.com/Wiki/View.aspx?ProjectName=IronPython IronPython<!-- Заголовок добавлен ботом -->]</ref>.

[[Stackless Python|Stackless]] — также написанная на Си реализация Python. Это не полноценная реализация, а [[патч]]и к CPython. Предоставляет расширенные возможности многопоточного программирования и значительно большую глубину [[рекурсия|рекурсии]].

[[Python for .NET]]<ref>[http://pythonnet.sourceforge.net/ Python for .NET]</ref> — ещё одна реализация Python для .NET. В отличие от IronPython эта реализация не компилирует Python код в MSIL, а только предоставляет интерпретатор, написанный на [[C Sharp|C#]]. Позволяет использовать .NET-сборки из Python кода.

[[PyPy]] — реализация Python, написанная на Python. Позволяет легко проверять новые возможности. В PyPy кроме стандартного CPython включены возможности Stackless, [[Psyco]], модификация [[Абстрактное синтаксическое дерево|AST]] «на лету» и многое другое. В проект интегрированы возможности анализа Python кода и трансляция в другие языки и [[байткод]]ы виртуальных машин ([[Си (язык программирования)|Си]], [[LLVM]], [[Javascript]], .NET с версии 0.9.9). Начиная с 0.9.0, возможна полностью автоматическая трансляция интерпретатора на Си, в результате чего достигается скорость, приемлемая для использования (в 2—3 раза медленнее чем CPython при отключённом [[JIT]] для версии 0.9.9). JIT находится в активной доработке.

[[python-safethread]]<ref name="google-safethread"/> — версия CPython без [[#Глобальная блокировка интерпретатора (GIL)|GIL]], что позволяет одновременно исполнять Python потоки на всех доступных процессорах. Внесены также некоторые другие изменения.

[[Unladen Swallow]] — начатый [[Google (компания)|Google]] проект по разработке высокоэффективного, максимально совместимого с CPython JIT-компилятора на базе [[LLVM]]. Согласно планам по развитию Python<ref>[http://www.python.org/dev/peps/pep-3146/ PEP 3146 — Merging Unladen Swallow into CPython<!-- Заголовок добавлен ботом -->]</ref>, планировалось перенести исходный код Unladen Swallow в CPython в версии 3.3<!--{{нет АИ|05|08|2011}} есть ссылка на PEP-3146, план развития Python-->. Но PEP-3146 был отменён в связи с отсутствием интереса к Unladen Swallow со стороны Google, основного спонсора разработки.<ref>[http://qinsb.blogspot.com/2011/03/unladen-swallow-retrospective.html QINSB is not a Software Blog: Unladen Swallow Retrospective<!-- Заголовок добавлен ботом -->]</ref>

[[tinypy]]<ref>[http://www.tinypy.org/ tinypy :: home<!-- Заголовок добавлен ботом -->]</ref> — минималистическая версия Python. Часть возможностей CPython не реализована.

[[Micro Python]] — эффективная реализация Python 3 для встроенных систем с малым объёмом оперативной памяти.<ref>[http://micropython.org/ Micro Python]</ref>

[[Python for S60|Brython]]<ref>{{Cite web|url = http://www.brython.info/|title = Сайт проекта Brython|author = |date = |publisher = }}</ref> — реализация языка на клиентском JavaScript, позволяющая писать браузерные скрипты на Python 3.

[[QPython]]<ref>{{Cite web|url = http://qpython.com/|title = Сайт проекта QPython}}</ref> — Реализация python для Android. Проект все-еще на стадии тестирования, однако, на qpython уже портированы некоторые самые необходимые библиотеки. Позволяет и работать в интерактивном режиме. Существует, также, Qpython3.

== Дальнейшая разработка ==
[[Python Enhancement Proposal]] («PEP») — это документ со стандартизированным дизайном, предоставляющий общую информацию о языке Python, включая новые предложения, описания и разъяснения возможностей языка. PEP предлагаются как основной источник для предложения новых возможностей и для разъяснения выбора того или иного дизайна для всех основных элементов языка. Выдающиеся PEP рецензируются и комментируются [[Гвидо ван Россум]]ом, имеющим в проекте статус «[[Великодушный пожизненный диктатор|великодушного пожизненного диктатора]]».

=== График и совместимость ===
Серии Python 2.x и Python 3.x в течение нескольких выпусков будут существовать параллельно, при этом серия 2.x будет использоваться для совместимости и скорее всего в неё будут включены некоторые возможности серии 3.x. PEP 3000 содержит больше информации о планируемых выпусках.

Python 3.0 обратно не совместим с предыдущей серией 2.x. Код Python 2.x скорее всего будет выдавать ошибки при исполнении в Python 3.0. Динамическая типизация Python вместе с планами изменения нескольких методов словарей делает механический перевод из Python 2.x в Python 3.0 очень сложным. Однако, утилита «2to3» уже способна сделать большинство работы по переводу кода, указывая на подозрительные его части с помощью комментариев и предупреждений. PEP 3000 рекомендует держать исходный код для серии 2.x и делать выпуски для Python 3.x с помощью «2to3». Полученный код не следует редактировать, пока программа не будет работоспособной в Python 2.x.

=== Возможности ===
Основные изменения, внесённые в версии 3.0:<ref>[http://docs.python.org/dev/3.0/whatsnew/3.0.html What’s New In Python 3.0 — Python v3.0.1 documentation<!-- Заголовок добавлен ботом -->]</ref><ref>[http://docs.python.org/3.0/index.html Overview — Python v3.0.1 documentation<!-- Заголовок добавлен ботом -->]</ref>
* Синтаксическая возможность для аннотации параметров и результата функций (например, для передачи информации о типе или документирования).
* Полный переход на [[unicode]] для строк.
* Введение нового типа «неизменяемые байты» и типа «изменяемый буфер». Оба необходимы для представления бинарных данных.
* Новая подсистема ввода-вывода (модуль <code>io</code>), имеющая отдельные представления для бинарных и текстовых данных.
* [[Абстрактный класс|Абстрактные классы]], [[Абстрактный метод|абстрактные методы]] (доступно уже в 2.6).
* Иерархия типов для чисел.
* Выражения для словарей и множеств <code>{k: v for k, v in a_dict}</code> и <code>{el1, el2, el3}</code> (по аналогии со списковыми выражениями).
* Изменения <code>print</code> из встроенного выражения во встроенную функцию. Это позволит модулям делать изменения, подстраиваясь под разное использование функции, а также упростит код. В Python 2.6 эта возможность активируется вводом <code>from __future__ import print_function</code>.
* Перемещение <code>reduce</code> (но не <code>map</code> или <code>filter</code>) из встроенного пространства в модуль <code>functools</code> (использование <code>reduce</code> существенно менее читабельно по сравнению с циклом).
* Удаление некоторых устаревших возможностей, поддерживаемых в ветке 2.x для совместимости, в частности: классы старого стиля, целочисленное деление с обрезанием результата как поведение по умолчанию, строковые исключения, неявный относительный импорт, оператор <code>exec</code> и т. п.
* Реорганизация стандартной библиотеки.
* Новый синтаксис для метаклассов.
* Изменен синтаксис присваиваний. Стало возможным, например, присваивание <code>(a, *rest, b) = range(5)</code>. С другой стороны, [[Параметр (программирование)|формальные параметры]] функций вроде <code>def foo(a, (b, c))</code> более недопустимы.

== Специализированные подмножества/расширения Python ==

На основе Python было создано несколько специализированных подмножеств языка, в основном предназначенных для статической компиляции в машинный код. Некоторые из них:

RPython<ref>[http://codespeak.net/pypy/dist/pypy/doc/coding-guide.html#restricted-python PyPy[coding-guide&#93;<!-- Заголовок добавлен ботом -->]</ref> — созданная в рамках проекта [[PyPy]] сильно ограниченная реализация Python без динамизма времени исполнения и некоторых других возможностей. Код на RPython можно компилировать во множество других языков/платформ — C, JavaScript, Lisp, .NET<ref>[http://codespeak.net/pypy/dist/pypy/doc/carbonpython.html PyPy carbonpython]</ref>, [[LLVM]]. На RPython написан интерпретатор PyPy.

Pyrex<ref name="pyrex">[http://www.cosc.canterbury.ac.nz/greg.ewing/python/Pyrex/ Pyrex<!-- Заголовок добавлен ботом -->]</ref> — ограниченная реализация Python, но несколько меньше, чем RPython. Pyrex расширен возможностями статической типизации типами из языка С и позволяет свободно смешивать типизированный и не типизированный код. Предназначен для написания модулей расширений, компилируется в код на языке С.

[[Cython]]<ref>[http://www.cython.org/ Cython: C-Extensions for Python<!-- Заголовок добавлен ботом -->]</ref> — расширенная версия Pyrex.

Проект [[Shedskin]] — предназначен для компиляции неявно статически типизированного кода на Python в оптимизированный код на языке С++.

== Применение ==
{{main|Проект:Информационные технологии/Списки/Список программного обеспечения, написанного на языке программирования Python|l1=Использование Python}}
Python — стабильный и распространённый язык. Он используется во многих проектах и в различных качествах: как основной язык программирования или для создания расширений и интеграции приложений. На Python реализовано большое количество проектов, также он активно используется для создания прототипов будущих программ. Python используется во многих крупных компаниях.<ref>[http://www.python.org/about/success/usa Python Success Stories<!-- Заголовок добавлен ботом -->]</ref>

Python с пакетами [[NumPy]], [[SciPy]] и [[Matplotlib|MatPlotLib]] активно используется как универсальная среда для научных расчётов в качестве замены распространенным специализированным коммерческим пакетам [[Matlab]], [[IDL]] и др.

В профессиональных программах трехмерной графики, таких как [[Houdini (графическая программа)|Houdini]] и [[Nuke]], Python используется для расширения стандартных возможностей программ.<ref>[http://sites.google.com/site/pythonforscientists/python-vs-matlab Python vs Matlab] Python for scientists blog</ref><ref>[http://www.astrobetter.com/wiki/tiki-index.php?page=idl_vs_python IDL vs. Python] AstroBetter Wiki</ref>

== См. также ==
* [[Сравнение командных оболочек]]
* [[Сравнение IDE#Python|Сравнение интегрированных средств разработки (IDE)]]

== Примечания ==
{{примечания|2}}

== Литература ==
{{викифицировать литературу}}
; На русском языке
* ''Коэльё Л.П., Ричерт В''. Построение систем машинного обучения на языке Python. — Перевод с английского. — М.: ДМК Пресс, 2015. —  с. — ISBN 978-5-97060-330-7.
* ''Маккинли У''. Python и анализ данных. — Перевод с английского. — М.: ДМК Пресс, 2015. — 482 с. — ISBN 978-5-97060-315-4.
* ''Марк Саммерфилд''. Python на практике. — Перевод с английского. — М.: ДМК Пресс, 2014. — 338 с. — ISBN 978-5-97060-095-5.
* {{книга|автор=Марк Лутц.|заглавие=Программирование на Python|издание=4-е изд|том=II|ответственный=Пер. с англ|место={{СПб.}}|издательство=[[Символ-Плюс]]|год=2011|isbn=978-5-93286-211-7}}
* {{книга|автор=Марк Лутц.|ссылка=http://www.symbol.ru/date/841171.html|заглавие=Программирование на Python|издание=4-е изд|том=I|ответственный=Пер. с англ|место={{СПб.}}|издательство=[[Символ-Плюс]]|год=2011|страниц=992|isbn=978-5-93286-210-0}}
* ''Марк Лутц''. [http://www.symbol.ru/date/816603.html Изучаем Python, 4-е издание]. — Перевод с английского. — СПб.: [[Символ-Плюс]], 2010. — 1280 с — ISBN 978-5-93286-159-2
* ''Дэвид М. Бизли''. [http://www.symbol.ru/date/784182.html Python. Подробный справочник, 4-е издание]. — Перевод с английского. — СПб.: [[Символ-Плюс]], 2010. — 864 с — ISBN 978-5-93286-157-8
* ''Марк Саммерфилд''. [http://www.symbol.ru/date/661501.html Программирование на Python 3. Подробное руководство]. — Перевод с английского. — СПб.: [[Символ-Плюс]], 2009. — 608 с — ISBN 978-5-93286-161-5
* ''Ноа Гифт, Джереми М. Джонс''. [http://www.symbol.ru/date/634254.html Python в системном администрировании UNIX и Linux]. — Перевод с английского. — СПб.: [[Символ-Плюс]], 2009. — 512 с — ISBN 978-5-93286-149-3
* Бизли, Дэвид М. Язык программирования Python. Справочник. — К.: ДиаСофт, 2000. — 336 с. — ISBN 966-7393-54-2, ISBN 0-7357-0901-7
* Сузи Р. А. Python. Наиболее полное руководство (+CD). — СПб.: БХВ-Петербург, 2002. — 768 с. — ISBN 5-94157-097-X
* Сузи Р. А. Язык программирования Python: Учебное пособие. — М.: ИНТУИТ, БИНОМ. Лаборатория знаний, 2006. — 328 с. — ISBN 5-9556-0058-2, ISBN 5-94774-442-2
* {{Книга|автор=Доусон М.|ссылка=|заглавие=Программируем на Python|место={{СПб.}}|издательство=[[Питер (издательство)|Питер]]|год=2012|страниц=432|isbn=978-5-459-00314-7}}
* {{Книга|автор=С. Шапошникова.|ссылка=http://younglinux.info/pdf|заглавие=Основы программирования на Python. Учебник. Вводный курс|издание=версия 2|год=2011|страниц=44}}
* {{книга|автор=И. А. Хахаев.|ссылка=http://www.altlinux.org/Books:PythonSchool|заглавие=Практикум по алгоритмизации и программированию на Python. Учебник|место={{М.}}|издательство=[[ALT Linux (компания)|Альт Линукс]]|год=2010|страниц=126|серия=Библиотека ALT Linux|isbn=978-5-905167-02-7}}
* {{книга|автор=А. Н. Чаплыгин.|заглавие=Учимся программировать вместе с Питоном. Учебник|год=ревизия 226|страниц=135}}

; На английском языке
* {{книга|автор=David Beazley, Guido Van Rossum.|заглавие=Python: Essential Reference|издательство=New Riders Publishing|год=1999}}
* Martin C. Brown. Python: The Complete Reference. McGraw-Hill Professional Publishing, 2001
* Wesley J. Chun. Core Python Programming. Prentice Hall PTR, 2000
* Alan Gauld. Learn to Program Using Python: A Tutorial for Hobbyists, Self-Starters, and Those Who Want to Learn the Art of Programming. Addison-Wesley Professional, 2001
* John E. Grayson. Python and Tkinter Programming. Manning Publications Company, 1999
* Rashi Gupta. Making use of Python. Wiley, 2002
* Mark Hammond, Andy Robinson. Python Programming on Win32. O’Reilly, 2000
* Christopher A. Jones, Fred L. Drake. Python & XML. O’Reilly & Associates, 2001
* Ivan Van Laningham. Teach Yourself Python in 24 Hours. Sams, 2000
* Amos Latteier, Michel Pelletier. The Zope Book. New Riders Publishing, 2001
* Frederik Lundh. Python Standard Library. O’Reilly & Associates, 2001
* {{книга|автор=A. Sweigart.|ссылка=http://inventwithpython.com/chapters/|заглавие=Invent Your Own Computer Games with Python|год=2008—2010|страниц=436|isbn=978-0-9821060-1-3}}
* {{книга|автор=A. Sweigart.|ссылка=http://corepython.com/|заглавие=Core Python Applications Programming|год=2012|страниц=888|isbn=978-0-1326782-0-9}}

== Ссылки ==
{{Навигация
 |Тема         = Python
 |Портал       = Свободное программное обеспечение
 |Викисловарь  = 
 |Викиверситет = Категория:Python
 |Викиучебник  = Python
 |Викицитатник = 
 |Викитека     = Категория:Python
 |Викивиды     = 
 |Викиновости  = 
 |Метавики     = 
 |Проект       = 
}}
* [http://www.python.org/ Официальный сайт]{{ref-en}}
* [http://wiki.python.org/moin/RussianLanguage Каталог ссылок на русскоязычные материалы по Python на официальном вики-сайте.]{{ref-en}}

{{Python}}
{{Языки программирования}}
{{FOSS}}

{{Избранная статья|Компьютер}}

[[Категория:Python|*]]
[[Категория:Статьи с примерами кода Python]]
[[Категория:Языки с динамической типизацией]]
[[Категория:Языки веб-программирования]]
[[Категория:Высокоуровневые языки программирования]]
